# Thoughtful Randomness
#### Video Demo:  <https://youtu.be/r0XF2ITnXcc>
#### Description:
Thoughtful Randomness is a randomized group generator that takes certain preferences into account. After a user first fill in a field of how many people they wish to group, they will be brought to a page where they can indicate how many groups they wish to have out of these people. Below that input field on this new page, users are given a table with 3 columns and the number of rows needed for people they originally inputted. The user will insert the names of the people they want to group and use the accordions in the following two columns to indicate any preferences. Once ready, the user can hit the “Create Groups” button and are redirected to a page showing each of the generated groups in table form. From there, the user may choose to regenerate groups using the same preferences as before or return to homepage to start a new grouping process. This web app is made to accommodate all screen sizes.

In app.py, I’ve imported “secrets” so I can use the session to remember values the user inputted across different pages, and “math” to use the math.ceil function. I’ve also of course added some basic things from flask, and flask_session, and configured the session to use filesystem instead of signed cookies. Another thing I imported was “random”, which is used in scrambling certain things to give that randomizer aspect.
All my html files extend from a file called layout.html, where all the setup, inclusion of bootstrap and stylesheet resources, titles, headers, and footers are done. In my styles.css, my “header” basically transforms the div with “Thoughtful Randomness” written inside of it into a block with a background image of a pattern I made that has rounded corners. This was done with padding, and the centering of the text was done with text-align. The footer was another div that was beautified using CSS to have a background color cohesive with the main turquoise color in my pattern image. The footer’s text indicates my name. Using Jinja blocks, these components are extended to all pages.

Index.html is pretty simple, with just a few headers, text for explaining the webapp, and the input field for users to input the number of people they wish to group. Following regular logic, the user cannot input a number less than 1. In the @app.route for the index page, if the method is “post”, the app.py takes that number and remembers it. If the method is “get”, the user is probably visiting the page for the first time and app.py renders index.html. This logic for “post” and “get” are applied throughout all my other html pages, expect that for all others, the user shouldn’t be visiting the page via “get”, so it always redirects them to “/”. For CSS, I’ve made all the header types other than header 1 the same navy color as that in my pattern image. For header 2, I’ve also italicized it to make it fancier. For the buttons, I used some of the bootstrap features but changed the colour to match the turquoise of the footer.

Input.html is the most exciting page with the field for “Number of Groups” and the table to input names and preferences. The table was constructed using a Jinja loop to have the right number of rows. When adding names to the first column, checkboxes for groupmate preferences and separation preferences are dynamically added to the accordions via JavaScript. The accordion used some Bootstrap JavaScript but modified to only have one accordion item and no label. The labels for the checkboxes are the names inputted in the first column for the user to check off, and these names are alphabetically sorted for convenience of finding names in the list. The person’s own name does not appear in these accordions, and once a grouping preferences name is checked, the name will automatically be removed from the separation preferences list and vice versa. This involved two functions: updatePreferences and updateDispreferences, which were called upon each time something was changed via oninput and onchange. In both functions, an array of names from the first column is gathered and sorted, and loops and conditionals are used to iterate each name in the array to figure out whether checkboxes needed to be added or not. After creating new elements for the checkboxes, and setting certain ids, types, styles, etc., each checkbox was appended to the list in the accordions.

The python for input.html is fun. My order of priority was to separate first, deal with preferences next, and finally split any people who didn’t have preferences off. After gathering all the information needed and saving it to the session then bringing some previously saved information back via session.get, I created my create_groups function. I first made all the empty groups needed, and shuffled the names in column 1 for that element of randomness. A process of finding whether a person was associated with a dispreference or preference (if they themselves had dispreferences or preferences or they were a dispreference or preference of someone else), and who they were associated with was followed. Whether they were associated with a dispreference superseded all else. All the names were separated into the 3 categories of dispreferences_associated, preferences_associated, and, only if they are none of the other two, free_names. The first 2 arrays were then sorted based on how many people those dispreferences and preferences were associated with, so the largest tasks could be done first. For each name in dispreferences_associated and preferences_associated, the best groups for those people were found using the functions best_separation and best_join.

Best_separation iterates over all the groups and first makes decision on whether to consider a group based on whether it still has room (the limit on people per group is number of people divided by the number of groups rounded up to the nearest integer). Using a counter that increments if there is a person the person needs to be separated from in the group and comparing values of the counter for each group, it returns the best group, which is the one that has the lowest count.

Best_join follows a similar process, with a max_count instead of a min_count, but it also takes the sizing of a group of associated people into account. This is so that if the person being sorted into the group is the first of their group of associated people, the chance that the remaining people from that group of associates will be added to the same group when it’s their turn to be sorted.

Finally, all the free_names are put into the first group that still has space. Since the names were already randomized in the beginning, there is no need to do so again. The page shows another paragraph, and the tables including all the groupings below. Below those, the user can randomize again or return to homepage. Randomize again basically visits the route via “post” and after fetching all the needed information using session.get, the python in app.py just calls the create_groups function again. Pressting “Return to Hompage” redirects the user back to the beginning.

Other than the CSS mentioned in the previous sections, I also created a class called “small_break” so I could have spaces slightly smaller than a regular break, and a class called “explanation” for all the text that wasn’t headers to have margins slightly further away from the edges of the screen for neatness.

